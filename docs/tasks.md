# TASKS (AI 개발 파트너용 프롬프트 설계서)
## C-Level AI Agent Service - Development Roadmap

**버전**: v1.0  
**작성일**: 2026-01-10  
**프로젝트**: CEO를 위한 맞춤형 AI 에이전트 서비스

---

## 개요 (Overview)

본 문서는 AI 코딩 파트너가 C레벨 AI 에이전트 서비스를 단계별로 개발할 수 있도록 구조화된 태스크 모음입니다. 각 마일스톤은 PRD, TRD, User Flow, Database Design, Design System 문서를 참조하며, 명확한 인수 조건(Acceptance Criteria)을 포함합니다.

**개발 원칙**:
- **플로우 엔지니어링**: 한 단계의 출력이 다음 단계의 입력이 됨
- **점진적 개발**: MVP → 핵심 기능 → 고급 기능 순서
- **자가 검증**: 각 태스크 완료 후 인수 조건 체크 및 자가 수정

---

## Milestone 1: 프로젝트 초기 설정 및 인프라 구축

**목표**: 개발 환경 구축, 기술 스택 설정, 기본 프로젝트 구조 생성

**참조 문서**: 
- TRD 섹션 5 (권장 기술 스택)
- TRD 섹션 8 (개발 및 배포 전략)

---

### [] Task 1.1: 프로젝트 초기화 및 기술 스택 설정

**컨텍스트**: 
C레벨 AI 에이전트 서비스는 Next.js 14 (App Router), TypeScript, Supabase를 기반으로 개발됩니다. TRD 섹션 5.2에 명시된 대로 shadcn/ui와 Tailwind CSS를 사용하여 전문적인 UI를 구현합니다.

**사용자 스토리**: 
개발자로서, 프로젝트를 빠르게 시작하고 일관된 개발 환경을 유지하기 위해 초기 설정을 자동화하고 싶습니다.

**기술 명세**:
1. Next.js 14 프로젝트 생성 (App Router 사용)
2. 필수 의존성 설치: Supabase 클라이언트, Zustand, React Query, Lucide Icons, Recharts
3. shadcn/ui 초기화 및 핵심 컴포넌트 설치 (button, input, card, badge, alert, dialog, dropdown-menu)
4. 프로젝트 구조 생성:
   - `src/app/` (라우팅)
   - `src/components/` (UI 컴포넌트)
   - `src/lib/` (유틸리티 및 API 클라이언트)
   - `src/types/` (TypeScript 타입 정의)
5. 환경 변수 설정 (`.env.local`)
6. Tailwind 설정에 Design System 색상 토큰 추가

**인수 조건 (Acceptance Criteria)**:
- [ ] Next.js 14 프로젝트가 성공적으로 생성되고 `npm run dev`로 실행됨
- [ ] TypeScript 설정이 strict 모드로 구성됨
- [ ] Tailwind CSS가 정상 작동하며 Design System의 색상 토큰이 `tailwind.config.ts`에 정의됨
- [ ] shadcn/ui 컴포넌트가 설치되고 테스트 페이지에서 렌더링됨
- [ ] 프로젝트 구조가 명시된 대로 생성됨
- [ ] `.env.local` 파일이 생성되고 `.gitignore`에 추가됨

**자가 수정 지침**:
위 인수 조건을 하나씩 확인하세요. 각 항목이 체크되지 않으면 해당 부분을 수정하고 다시 검증하세요. 특히 Tailwind 색상 토큰이 Design System 문서의 색상 팔레트와 일치하는지 확인하세요.

---

### [] Task 1.2: Supabase 데이터베이스 스키마 생성

**컨텍스트**: 
Database Design 문서에 정의된 12개 엔티티를 Supabase PostgreSQL에 생성합니다. Row-Level Security (RLS)를 활성화하여 사용자별 데이터 격리를 구현합니다.

**사용자 스토리**: 
개발자로서, 데이터베이스 스키마를 코드로 관리하고 버전 관리하여 팀원과 동기화하고 싶습니다.

**기술 명세**:
1. Supabase 프로젝트 생성 및 연결
2. 마이그레이션 SQL 파일 작성:
   - Database Design 문서의 ERD를 기반으로 CREATE TABLE 문 작성
   - 모든 테이블에 UUID 기본 키 사용
   - 외래 키 제약조건 및 인덱스 추가
   - 타임스탬프 필드에 자동 생성 설정
3. 주요 테이블 생성: users, agents, conversations, messages, reports, context_store, agent_collaborations, notifications, audit_logs
4. 인덱스 생성 (Database Design 문서 참조)
5. Row-Level Security (RLS) 정책 설정
6. pgvector 확장 활성화 (지식 베이스용)

**인수 조건 (Acceptance Criteria)**:
- [ ] 모든 12개 테이블이 Supabase에 생성됨
- [ ] 외래 키 제약조건이 정상 작동함
- [ ] Database Design 문서의 모든 인덱스가 생성됨
- [ ] RLS 정책이 활성화되고 테스트됨
- [ ] pgvector 확장이 활성화됨
- [ ] Supabase Studio에서 테이블 구조 확인 가능

**자가 수정 지침**:
Supabase Studio에서 각 테이블을 열어 컬럼, 타입, 제약조건이 Database Design 문서와 일치하는지 확인하세요. RLS 정책은 Supabase Auth를 사용하여 실제 사용자로 로그인 후 테스트하세요.

---

### [] Task 1.3: 인증 시스템 구현 (Supabase Auth)

**컨텍스트**: 
TRD 섹션 2.2에 명시된 OAuth 2.0 기반 인증을 Supabase Auth로 구현합니다. CEO 및 C레벨 임원만 접근 가능하도록 역할 기반 접근 제어(RBAC)를 설정합니다.

**사용자 스토리**: 
CEO로서, 안전하게 로그인하고 내 대화 기록과 보고서에만 접근하고 싶습니다.

**기술 명세**:
1. Supabase Auth 클라이언트 설정
2. 로그인 페이지 생성: 이메일/비밀번호 입력 폼, Design System 스타일 적용
3. 회원가입 페이지 생성: 이메일, 비밀번호, 이름, 역할 입력, 역할 검증
4. 인증 미들웨어 생성: 미인증 사용자 리디렉션
5. 사용자 프로필 훅 생성
6. 로그아웃 기능 구현

**인수 조건 (Acceptance Criteria)**:
- [ ] 로그인 페이지가 렌더링되고 이메일/비밀번호 입력 가능
- [ ] 유효한 자격 증명으로 로그인 시 대시보드로 리디렉션됨
- [ ] 잘못된 자격 증명 시 에러 메시지 표시
- [ ] 회원가입 시 `users` 테이블에 데이터 저장됨
- [ ] 미인증 사용자가 보호된 경로 접근 시 로그인 페이지로 리디렉션됨
- [ ] 로그아웃 기능이 정상 작동함
- [ ] Design System의 스타일이 적용됨

**자가 수정 지침**:
브라우저에서 로그인/로그아웃을 여러 번 테스트하세요. 개발자 도구의 Network 탭에서 Supabase API 호출을 확인하고, Application 탭에서 세션 쿠키를 확인하세요.

---

## Milestone 2: 핵심 기능 - 질의 분석 및 에이전트 라우팅 (FEAT-1)

**목표**: CEO의 자연어 질의를 분석하여 적절한 C레벨 에이전트로 라우팅

**참조 문서**: 
- PRD 섹션 5.1.1 (지능형 질의 분석 및 라우팅)
- TRD 섹션 1.2.1 (Query Analysis Engine)
- User Flow 섹션 2.2 (질의 분석 및 라우팅)

---

### [] Task 2.1: 에이전트 메타데이터 시드 데이터 생성

**컨텍스트**: 
5개의 C레벨 에이전트(CFO, CTO, CMO, COO, CHRO)를 `agents` 테이블에 초기 데이터로 삽입합니다. PRD 섹션 4에 정의된 각 에이전트의 페르소나를 반영합니다.

**사용자 스토리**: 
개발자로서, 에이전트 데이터를 코드로 관리하고 일관되게 배포하고 싶습니다.

**기술 명세**:
1. 시드 데이터 SQL 파일 작성
2. 각 에이전트의 `system_prompt` 작성 (PRD 섹션 4의 페르소나 기반)
3. `capabilities` JSON 배열 정의
4. `configuration` 설정 (LLM 모델, temperature 등)
5. Supabase에서 시드 데이터 실행

**인수 조건 (Acceptance Criteria)**:
- [ ] `agents` 테이블에 5개 에이전트 데이터가 삽입됨 (CFO, CTO, CMO, COO, CHRO)
- [ ] 각 에이전트의 `system_prompt`가 PRD의 페르소나와 일치함
- [ ] `capabilities`가 JSON 배열 형식으로 저장됨
- [ ] `configuration`에 LLM 모델 및 파라미터가 포함됨
- [ ] Supabase Studio에서 데이터 확인 가능

**자가 수정 지침**:
Supabase Studio에서 `agents` 테이블을 열어 5개 행이 있는지 확인하세요. 각 에이전트의 `system_prompt`를 읽고 PRD 섹션 4의 대화 스타일 및 전문 영역과 일치하는지 검토하세요.

---

### [] Task 2.2: LLM 기반 질의 의도 분석 API 구현

**컨텍스트**: 
CEO의 자연어 질의를 OpenAI GPT-4를 사용하여 분석하고, 적절한 에이전트를 선택합니다. TRD 섹션 1.2.1의 처리 흐름을 따릅니다.

**사용자 스토리**: 
CEO로서, "지난 분기 마케팅 ROI가 어땠나요?"라고 질문하면 자동으로 CMO 에이전트가 응답하길 원합니다.

**기술 명세**:
1. OpenAI 클라이언트 설정 (`src/lib/openai/client.ts`)
2. 질의 분석 API 엔드포인트 생성 (`src/app/api/analyze-query/route.ts`):
   - 에이전트 목록 조회
   - LLM에게 질의 분석 요청
   - JSON 형식 응답: primary_agent, confidence_score, reasoning, requires_collaboration, collaborating_agents
3. 프론트엔드 훅 생성 (`src/lib/hooks/useQueryAnalysis.ts`)
4. 에러 처리 구현

**인수 조건 (Acceptance Criteria)**:
- [ ] `/api/analyze-query` 엔드포인트가 POST 요청을 받음
- [ ] 질의 "지난 분기 재무 현황은?"에 대해 `primary_agent: "CFO"` 반환
- [ ] 질의 "마케팅 캠페인 성과와 비용 분석"에 대해 `requires_collaboration: true` 반환
- [ ] `confidence_score`가 0.0 ~ 1.0 범위
- [ ] 응답 시간이 3초 이내 (TRD 성능 요구사항)
- [ ] 에러 처리가 구현됨

**자가 수정 지침**:
다양한 질의를 시도하고 에이전트 선택이 합리적인지 확인하세요. `confidence_score`가 0.8 미만인 경우 명확화 질문을 생성하도록 로직을 추가하세요.

---

### [] Task 2.3: 대화 인터페이스 UI 구현

**컨텍스트**: 
CEO가 질의를 입력하고 에이전트 응답을 실시간으로 확인할 수 있는 채팅 인터페이스를 구현합니다. Design System의 스타일을 적용합니다.

**사용자 스토리**: 
CEO로서, 직관적인 채팅 인터페이스에서 질문을 입력하고 에이전트의 응답을 즉시 확인하고 싶습니다.

**기술 명세**:
1. 대시보드 페이지 생성 (`src/app/(dashboard)/page.tsx`):
   - 좌측: 대화 목록 사이드바
   - 우측: 메시지 영역 + 입력 필드
2. 메시지 컴포넌트 생성 (`src/components/chat/Message.tsx`):
   - CEO 메시지 (좌측 정렬)
   - 에이전트 메시지 (우측 정렬, 에이전트 아바타 포함)
3. 입력 필드 컴포넌트 (`src/components/chat/ChatInput.tsx`):
   - 텍스트 입력
   - 전송 버튼
   - 로딩 상태 표시
4. 에이전트 아바타 컴포넌트 (`src/components/agents/AgentAvatar.tsx`):
   - Design System의 에이전트별 색상 적용
5. 대화 목록 컴포넌트 (`src/components/chat/ConversationList.tsx`)

**인수 조건 (Acceptance Criteria)**:
- [ ] 대시보드 페이지가 렌더링되고 레이아웃이 PRD 섹션 7.2와 일치함
- [ ] 질의 입력 필드가 작동하고 Enter 키로 전송 가능
- [ ] 메시지가 대화 영역에 표시됨 (CEO 메시지 좌측, 에이전트 메시지 우측)
- [ ] 에이전트 아바타가 Design System의 색상으로 표시됨
- [ ] Design System의 타이포그래피 및 간격이 적용됨
- [ ] 반응형 디자인이 적용됨 (모바일, 태블릿, 데스크톱)

**자가 수정 지침**:
브라우저에서 대시보드를 열고 Design System 문서와 비교하세요. 색상, 폰트, 간격이 일치하는지 확인하고, 다양한 화면 크기에서 테스트하세요.

---

## Milestone 3: 멀티 에이전트 협업 시스템 (FEAT-2)

**목표**: 복합적인 질의에 대해 여러 C레벨 에이전트가 협업하여 통합된 답변 제공

**참조 문서**: 
- PRD 섹션 5.1.3 (멀티 에이전트 협업 시스템)
- TRD 섹션 1.2.2 (Agent Orchestration Layer)
- User Flow 섹션 2.3 (멀티 에이전트 협업)
- Database Design 섹션 3.7 (AGENT_COLLABORATIONS 테이블)

---

### [] Task 3.1: 에이전트 오케스트레이션 시스템 구현

**컨텍스트**: 
복합 질의를 감지하고, 여러 에이전트를 조율하여 통합된 응답을 생성합니다. TRD 섹션 1.2.2의 에이전트 오케스트레이션 레이어를 구현합니다.

**사용자 스토리**: 
CEO로서, "신제품 출시 전략을 검토하고 싶습니다"라고 질문하면, CFO, CTO, CMO, COO가 각자의 관점에서 분석하고 통합된 권고안을 받고 싶습니다.

**기술 명세**:
1. 복합 질의 감지 로직 구현 (`src/lib/orchestration/query-analyzer.ts`):
   - 질의가 여러 도메인을 포함하는지 판단
   - 필요한 에이전트 목록 결정
2. 에이전트 오케스트레이터 구현 (`src/lib/orchestration/orchestrator.ts`):
   - 병렬 실행 모드: 모든 에이전트 동시 호출
   - 순차 실행 모드: 한 에이전트의 결과를 다음 에이전트에 전달
   - 에이전트 간 데이터 공유
3. 응답 통합 로직 (`src/lib/orchestration/response-merger.ts`):
   - 각 에이전트의 응답 수집
   - 중복 제거 및 일관성 검증
   - 우선순위 정렬
   - 통합 보고서 생성
4. API 엔드포인트 생성 (`src/app/api/collaborate/route.ts`)
5. `agent_collaborations` 테이블에 협업 기록 저장

**인수 조건 (Acceptance Criteria)**:
- [ ] 복합 질의가 자동으로 감지됨
- [ ] 여러 에이전트가 병렬로 호출됨
- [ ] 각 에이전트의 응답이 수집되고 통합됨
- [ ] 통합 응답이 PRD 섹션 7.3의 UI 형식으로 표시됨
- [ ] `agent_collaborations` 테이블에 협업 기록이 저장됨
- [ ] 응답 시간이 10초 이내 (TRD 성능 요구사항)

**자가 수정 지침**:
"신제품 출시 전략" 질의를 테스트하세요. CFO, CTO, CMO, COO가 각각 재무, 기술, 마케팅, 운영 관점에서 분석하는지 확인하고, 통합 응답이 모든 관점을 포함하는지 검증하세요.

---

### [] Task 3.2: 멀티 에이전트 협업 UI 구현

**컨텍스트**: 
PRD 섹션 7.3의 멀티 에이전트 협업 화면을 구현합니다. 각 에이전트의 진행 상태와 응답을 실시간으로 표시합니다.

**사용자 스토리**: 
CEO로서, 여러 에이전트가 협업하는 과정을 실시간으로 확인하고, 각 에이전트의 관점을 개별적으로 또는 통합하여 볼 수 있기를 원합니다.

**기술 명세**:
1. 협업 상태 컴포넌트 생성 (`src/components/collaboration/CollaborationStatus.tsx`):
   - 참여 에이전트 목록
   - 각 에이전트의 진행 상태 (대기, 진행 중, 완료)
   - 진행률 표시
2. 에이전트 응답 카드 컴포넌트 (`src/components/collaboration/AgentResponseCard.tsx`):
   - 에이전트 아바타 및 이름
   - 응답 요약
   - "자세히 보기" 버튼
3. 통합 보고서 컴포넌트 (`src/components/collaboration/IntegratedReport.tsx`):
   - 각 에이전트의 주요 인사이트
   - 종합 권고안
   - 다음 단계 제안
4. 실시간 업데이트 구현 (Server-Sent Events 또는 Polling)

**인수 조건 (Acceptance Criteria)**:
- [ ] 협업 화면이 PRD 섹션 7.3의 레이아웃과 일치함
- [ ] 각 에이전트의 진행 상태가 실시간으로 업데이트됨
- [ ] 에이전트 응답 카드가 Design System 스타일로 표시됨
- [ ] "자세히 보기" 버튼 클릭 시 전체 응답이 표시됨
- [ ] 통합 보고서가 생성되고 표시됨
- [ ] 로딩 상태 및 에러 처리가 구현됨

**자가 수정 지침**:
협업 화면을 열고 각 에이전트의 상태 변화를 관찰하세요. 진행 중 → 완료 전환이 부드럽고, 통합 보고서가 모든 에이전트의 인사이트를 포함하는지 확인하세요.

---

### [] Task 3.3: 소크라테스식 대화 엔진 통합

**컨텍스트**: 
PRD 섹션 5.1.2에 정의된 소크라테스식 대화 구조를 에이전트 응답에 적용합니다. 단순 답변이 아닌, 질문을 통해 CEO의 사고를 확장합니다.

**사용자 스토리**: 
CEO로서, AI 에이전트가 단순히 답변하는 것이 아니라, 질문을 통해 내가 스스로 더 깊이 생각하도록 유도하길 원합니다.

**기술 명세**:
1. 대화 상태 관리 시스템 구현 (`src/lib/conversation/state-machine.ts`):
   - 5단계 상태 정의: CLARIFICATION, ASSUMPTION_EXPLORATION, EVIDENCE, ALTERNATIVE_EXPLORATION, CONCLUSION
   - 상태 전환 로직
2. 각 단계별 프롬프트 템플릿 생성 (`src/lib/conversation/prompts.ts`):
   - 명확화 질문 생성
   - 가정 탐색 질문 생성
   - 증거 기반 분석 제공
   - 대안 제시
   - 실행 가능한 권고안 생성
3. 대화 컨텍스트 관리 (`src/lib/conversation/context-manager.ts`):
   - 이전 대화 내용 추적
   - 엔티티 추출 및 저장
   - 참조 표현 해석
4. 에이전트별 소크라테스식 질문 라이브러리 (`src/lib/agents/question-templates.ts`):
   - CFO: "이 투자의 ROI를 어떻게 측정하실 계획이신가요?" 등
   - CTO: "이 기술이 우리의 핵심 경쟁력을 어떻게 강화할까요?" 등
   - CMO: "우리의 타겟 고객이 진정으로 원하는 것은 무엇일까요?" 등
   - COO: "현재 운영 프로세스에서 가장 큰 병목 지점은 어디인가요?" 등
   - CHRO: "우리 조직의 핵심 가치가 일상 업무에 어떻게 반영되고 있나요?" 등

**인수 조건 (Acceptance Criteria)**:
- [ ] 대화 상태 머신이 5단계를 순차적으로 진행함
- [ ] 각 단계에서 적절한 질문 또는 분석이 생성됨
- [ ] 대화 컨텍스트가 유지되고 이전 답변을 참조함
- [ ] CEO가 "이전에 말한 그 프로젝트"와 같은 참조 표현을 사용할 수 있음
- [ ] 각 에이전트가 자신의 전문 영역에 맞는 소크라테스식 질문을 던짐
- [ ] 응답이 PRD 섹션 5.1.2의 대화 구조를 따름

**자가 수정 지침**:
실제 CEO 질의 시나리오를 테스트하세요. 예: "우리 회사의 현금 흐름이 걱정됩니다"라고 입력하고, 에이전트가 명확화 질문 → 가정 탐색 → 증거 제시 순서로 응답하는지 확인하세요. 각 에이전트에게 동일한 질의를 던지고, 에이전트별로 다른 관점의 질문을 하는지 확인하세요.

---

## Milestone 4: 보고서 생성 및 인사이트 추출 (FEAT-3)

**목표**: 대화 내용을 구조화된 보고서로 자동 변환, 시각화 자료 포함

**참조 문서**: 
- PRD 섹션 5.1.5 (보고서 생성 및 시각화)
- PRD 섹션 7.4 (보고서 화면)
- Database Design 섹션 3.8, 3.9 (REPORTS, REPORT_SECTIONS 테이블)

---

### [] Task 4.1: 보고서 자동 생성 시스템 구현

**컨텍스트**: 
대화 내용을 분석하여 구조화된 보고서를 자동 생성합니다. PRD 섹션 5.1.5의 보고서 유형을 지원합니다.

**사용자 스토리**: 
CEO로서, 중요한 대화 내용을 보고서로 저장하고, 나중에 검토하거나 팀원들과 공유하고 싶습니다.

**기술 명세**:
1. 보고서 생성 로직 구현 (`src/lib/reports/generator.ts`):
   - 대화 내용 분석
   - 핵심 인사이트 추출
   - 섹션별 구조화 (Executive Summary, 각 에이전트 분석, 종합 권고안)
2. 보고서 템플릿 시스템 (`src/lib/reports/templates.ts`):
   - 요약 보고서 템플릿
   - 상세 보고서 템플릿
   - 비교 보고서 템플릿
3. 시각화 데이터 생성 (`src/lib/reports/visualization.ts`):
   - Recharts 포맷으로 차트 데이터 변환
   - 재무 차트, KPI 대시보드, 트렌드 그래프
4. API 엔드포인트 생성 (`src/app/api/reports/generate/route.ts`)
5. `reports` 및 `report_sections` 테이블에 저장

**인수 조건 (Acceptance Criteria)**:
- [ ] 보고서 생성 요청 시 대화 내용이 구조화된 보고서로 변환됨
- [ ] 보고서가 PRD 섹션 7.4의 구조를 따름 (요약, 각 에이전트 분석, 종합 권고안)
- [ ] 시각화 데이터가 포함됨 (차트, 그래프)
- [ ] `reports` 및 `report_sections` 테이블에 저장됨
- [ ] 보고서 생성 시간이 10초 이내

**자가 수정 지침**:
생성된 보고서를 검토하세요. Executive Summary가 핵심 인사이트를 포함하는지, 각 섹션이 논리적으로 연결되는지, 시각화가 데이터를 명확히 전달하는지 확인하세요.

---

### [] Task 4.2: 보고서 UI 및 PDF 내보내기 구현

**컨텍스트**: 
생성된 보고서를 웹에서 보기 좋게 표시하고, PDF로 내보낼 수 있는 기능을 구현합니다.

**사용자 스토리**: 
CEO로서, 보고서를 웹에서 검토하고, 필요 시 PDF로 다운로드하여 오프라인에서 보거나 이메일로 공유하고 싶습니다.

**기술 명세**:
1. 보고서 페이지 생성 (`src/app/(dashboard)/reports/[id]/page.tsx`):
   - 보고서 제목 및 메타데이터
   - 섹션별 콘텐츠 렌더링
   - 시각화 차트 렌더링 (Recharts)
2. PDF 생성 라이브러리 통합 (react-pdf 또는 jsPDF):
   - 보고서 HTML을 PDF로 변환
   - 페이지 레이아웃 및 스타일 적용
3. 다운로드 버튼 구현
4. 공유 기능 구현 (링크 복사, 이메일 전송)
5. 보고서 목록 페이지 (`src/app/(dashboard)/reports/page.tsx`)

**인수 조건 (Acceptance Criteria)**:
- [ ] 보고서 페이지가 PRD 섹션 7.4의 레이아웃과 일치함
- [ ] 모든 섹션이 올바르게 렌더링됨
- [ ] 차트가 Recharts로 시각화됨
- [ ] PDF 다운로드 버튼 클릭 시 PDF 파일이 생성되고 다운로드됨
- [ ] PDF가 웹 화면과 유사한 레이아웃을 유지함
- [ ] 공유 기능이 작동함
- [ ] 보고서 목록 페이지에서 과거 보고서 조회 가능

**자가 수정 지침**:
보고서 페이지를 열고 모든 섹션이 표시되는지 확인하세요. PDF를 다운로드하여 열어보고, 레이아웃과 차트가 올바르게 렌더링되는지 검증하세요.

---

### [] Task 4.3: 인사이트 추출 및 추천 시스템

**컨텍스트**: 
대화 내용에서 핵심 인사이트를 자동으로 추출하고, CEO에게 관련 질문이나 다음 단계를 추천합니다.

**사용자 스토리**: 
CEO로서, AI가 대화 내용을 분석하여 내가 놓친 중요한 인사이트를 알려주고, 다음에 고려해야 할 질문을 제안해주길 원합니다.

**기술 명세**:
1. 인사이트 추출 로직 구현 (`src/lib/insights/extractor.ts`):
   - LLM을 사용하여 대화에서 핵심 인사이트 추출
   - 중요도 점수 부여
   - 카테고리 분류 (재무, 기술, 마케팅, 운영, 인사)
2. 추천 시스템 구현 (`src/lib/insights/recommender.ts`):
   - 대화 히스토리 분석
   - 관련 질문 생성
   - 다음 단계 제안
3. 인사이트 UI 컴포넌트 (`src/components/insights/InsightCard.tsx`):
   - 인사이트 표시
   - 중요도 표시
   - 관련 질문 표시
4. 대시보드에 인사이트 섹션 추가

**인수 조건 (Acceptance Criteria)**:
- [ ] 대화 종료 후 핵심 인사이트가 자동으로 추출됨
- [ ] 인사이트가 중요도 순으로 정렬됨
- [ ] 각 인사이트에 대한 관련 질문이 생성됨
- [ ] 대시보드에 인사이트 섹션이 표시됨
- [ ] 인사이트 클릭 시 관련 대화로 이동

**자가 수정 지침**:
여러 대화를 진행한 후 인사이트 섹션을 확인하세요. 추출된 인사이트가 대화의 핵심 내용을 반영하는지, 추천 질문이 관련성이 있는지 검토하세요.

---

## Milestone 5: 실시간 알림 및 컨텍스트 유지 (FEAT-4)

**목표**: 중요 이벤트 발생 시 CEO에게 실시간 알림 제공, 대화 컨텍스트 유지

**참조 문서**: 
- PRD 섹션 P2-8 (실시간 알림)
- User Flow 섹션 2.4 (실시간 알림 및 모니터링)
- User Flow 섹션 2.6 (대화 컨텍스트 유지)
- Database Design 섹션 3.6 (CONTEXT_STORE 테이블)
- Database Design 섹션 3.11 (NOTIFICATIONS 테이블)

---

### [] Task 5.1: 알림 시스템 구현

**컨텍스트**: 
중요한 이벤트(예: 재무 임계값 초과, 긴급 이슈 발생)가 발생하면 CEO에게 알림을 전송합니다.

**사용자 스토리**: 
CEO로서, 중요한 이슈가 발생하면 즉시 알림을 받아 신속하게 대응하고 싶습니다.

**기술 명세**:
1. 알림 생성 로직 구현 (`src/lib/notifications/generator.ts`):
   - 이벤트 감지 (예: 재무 지표 변화, 시스템 이상)
   - 알림 우선순위 결정 (긴급, 중요, 일반)
   - 알림 메시지 생성
2. 알림 전송 시스템 (`src/lib/notifications/sender.ts`):
   - 푸시 알림 (브라우저 Notification API)
   - 이메일 알림 (선택적)
   - 인앱 알림
3. 알림 UI 컴포넌트 (`src/components/notifications/NotificationBell.tsx`):
   - 알림 아이콘 (미읽음 개수 표시)
   - 알림 드롭다운
   - 알림 목록
4. API 엔드포인트 생성 (`src/app/api/notifications/route.ts`)
5. `notifications` 테이블에 저장

**인수 조건 (Acceptance Criteria)**:
- [ ] 중요 이벤트 발생 시 알림이 생성됨
- [ ] 알림이 우선순위에 따라 분류됨 (긴급, 중요, 일반)
- [ ] 푸시 알림이 브라우저에 표시됨
- [ ] 알림 아이콘에 미읽음 개수가 표시됨
- [ ] 알림 드롭다운에서 알림 목록을 확인할 수 있음
- [ ] 알림 클릭 시 관련 페이지로 이동함
- [ ] `notifications` 테이블에 저장됨

**자가 수정 지침**:
테스트 이벤트를 발생시켜 알림이 생성되는지 확인하세요. 브라우저 알림 권한을 허용하고, 푸시 알림이 표시되는지 테스트하세요.

---

### [] Task 5.2: 대화 컨텍스트 유지 시스템 구현

**컨텍스트**: 
User Flow 섹션 2.6에 정의된 대화 컨텍스트 유지 시스템을 구현합니다. CEO가 "이전에 말한 그 프로젝트"와 같은 참조 표현을 사용할 수 있도록 합니다.

**사용자 스토리**: 
CEO로서, 이전 대화를 참조하면서 자연스럽게 대화를 이어가고 싶습니다. "그때 말한 그 프로젝트"라고 말하면 AI가 이해하길 원합니다.

**기술 명세**:
1. 컨텍스트 저장 로직 구현 (`src/lib/conversation/context-store.ts`):
   - 각 대화 턴마다 컨텍스트 스냅샷 저장
   - 엔티티 추출 (시간, 부서, 지표, 프로젝트 등)
   - 의도 및 주제 추적
2. 참조 표현 해석 (`src/lib/conversation/reference-resolver.ts`):
   - "그 프로젝트", "이전에 말한", "그때" 등 참조 표현 감지
   - 컨텍스트 히스토리에서 참조 대상 검색
   - 참조 대상으로 질의 재구성
3. 장기 기억 시스템 (`src/lib/conversation/long-term-memory.ts`):
   - 중요한 정보를 장기 기억으로 저장
   - 세션 종료 후에도 유지
   - 지식 베이스 업데이트
4. `context_store` 테이블에 저장

**인수 조건 (Acceptance Criteria)**:
- [ ] 각 대화 턴마다 컨텍스트가 `context_store` 테이블에 저장됨
- [ ] 엔티티가 정확하게 추출됨 (시간, 부서, 지표 등)
- [ ] 참조 표현이 감지되고 올바르게 해석됨
- [ ] CEO가 "이전에 말한 그 프로젝트"라고 질문하면 AI가 이해함
- [ ] 세션 종료 후에도 중요한 정보가 유지됨
- [ ] 다음 세션에서 이전 대화를 참조할 수 있음

**자가 수정 지침**:
여러 턴의 대화를 진행하세요. 예: "신제품 출시를 고려 중입니다" → (몇 턴 후) "그 제품의 마케팅 전략은?" 두 번째 질문에서 AI가 "신제품"을 올바르게 참조하는지 확인하세요.

---

### [] Task 5.3: 프로액티브 인사이트 및 알림

**컨텍스트**: 
AI가 대화 내용과 기업 데이터를 분석하여 CEO에게 선제적으로 중요한 인사이트나 경고를 제공합니다.

**사용자 스토리**: 
CEO로서, AI가 내가 묻지 않아도 중요한 변화나 이슈를 먼저 알려주길 원합니다.

**기술 명세**:
1. 이벤트 모니터링 시스템 구현 (`src/lib/monitoring/event-monitor.ts`):
   - 재무 지표 모니터링 (임계값 초과 감지)
   - 시장 트렌드 변화 감지
   - 경쟁사 동향 추적
   - 내부 이슈 감지
2. 프로액티브 인사이트 생성 (`src/lib/insights/proactive-generator.ts`):
   - 모니터링 데이터 분석
   - 중요도 판단
   - 인사이트 메시지 생성
3. 알림 트리거 로직:
   - 긴급 이슈: 즉시 푸시 알림
   - 중요 인사이트: 이메일 알림
   - 일반 정보: 대시보드에 표시
4. 대시보드에 프로액티브 인사이트 섹션 추가

**인수 조건 (Acceptance Criteria)**:
- [ ] 재무 지표가 임계값을 초과하면 자동으로 알림 생성
- [ ] 중요한 시장 변화가 감지되면 인사이트 생성
- [ ] 긴급 이슈는 즉시 푸시 알림으로 전송
- [ ] 대시보드에 프로액티브 인사이트 섹션 표시
- [ ] CEO가 알림을 클릭하면 상세 정보 및 권고안 표시

**자가 수정 지침**:
테스트 데이터로 임계값 초과 시나리오를 시뮬레이션하세요. 알림이 생성되고, 적절한 채널(푸시, 이메일, 대시보드)로 전송되는지 확인하세요.

---

## Milestone 6: 배포 및 모니터링 (FEAT-5)

**목표**: 프로덕션 환경 배포, 성능 최적화, 모니터링 시스템 구축

**참조 문서**: 
- TRD 섹션 2 (비기능적 요구사항)
- TRD 섹션 7 (성능 최적화 전략)
- TRD 섹션 8 (개발 및 배포 전략)

---

### [] Task 6.1: 성능 최적화

**컨텍스트**: 
TRD 섹션 2.1의 성능 요구사항을 충족하도록 시스템을 최적화합니다.

**사용자 스토리**: 
CEO로서, 질의에 대한 응답을 빠르게 받아 의사결정 속도를 높이고 싶습니다.

**기술 명세**:
1. 데이터베이스 쿼리 최적화:
   - N+1 쿼리 방지
   - 인덱스 활용 확인
   - 쿼리 실행 계획 분석
2. LLM API 호출 최적화:
   - 응답 캐싱 (Redis)
   - 프롬프트 길이 최소화
   - 스트리밍 응답 활용
3. 프론트엔드 최적화:
   - 코드 스플리팅
   - 이미지 최적화
   - 레이지 로딩
4. CDN 설정 (정적 자산)
5. 성능 모니터링 도구 통합 (Vercel Analytics 또는 Google Analytics)

**인수 조건 (Acceptance Criteria)**:
- [ ] 질의 응답 시간이 평균 3초 이내 (단일 에이전트)
- [ ] 복합 질의 응답 시간이 10초 이내 (멀티 에이전트)
- [ ] 페이지 로드 시간이 2초 이내
- [ ] Lighthouse 성능 점수 90 이상
- [ ] 데이터베이스 쿼리 시간이 100ms 이내
- [ ] LLM API 호출이 캐싱됨 (동일 질의 반복 시)

**자가 수정 지침**:
Chrome DevTools의 Performance 탭에서 성능을 프로파일링하세요. 병목 지점을 식별하고 최적화하세요. Lighthouse 보고서를 실행하여 개선 사항을 확인하세요.

---

### [] Task 6.2: 보안 강화

**컨텍스트**: 
TRD 섹션 2.2의 보안 요구사항을 충족하도록 시스템을 강화합니다.

**사용자 스토리**: 
CEO로서, 내 대화 내용과 기업 데이터가 안전하게 보호되길 원합니다.

**기술 명세**:
1. 데이터 암호화:
   - HTTPS 강제 (TLS 1.3)
   - 민감 데이터 필드 암호화 (AES-256)
   - 비밀번호 해싱 (bcrypt)
2. API 보안:
   - Rate limiting (분당 60 요청)
   - CORS 정책 설정
   - API Key 관리
3. 입력 검증:
   - SQL Injection 방지
   - XSS 방지
   - CSRF 토큰
4. 감사 로그:
   - 모든 CUD 작업 로깅
   - IP 주소 및 User Agent 기록
5. 다단계 인증 (MFA) 구현 (선택적)

**인수 조건 (Acceptance Criteria)**:
- [ ] 모든 HTTP 요청이 HTTPS로 리디렉션됨
- [ ] 민감 데이터가 암호화되어 저장됨
- [ ] Rate limiting이 작동함
- [ ] 입력 검증이 모든 API 엔드포인트에 적용됨
- [ ] 감사 로그가 `audit_logs` 테이블에 저장됨
- [ ] OWASP Top 10 취약점이 해결됨
- [ ] 보안 헤더가 설정됨 (CSP, X-Frame-Options 등)

**자가 수정 지침**:
보안 스캐너(예: OWASP ZAP)를 실행하여 취약점을 확인하세요. 각 취약점을 수정하고 재스캔하여 해결되었는지 검증하세요.

---

### [] Task 6.3: CI/CD 파이프라인 구축

**컨텍스트**: 
TRD 섹션 8.2의 배포 전략에 따라 CI/CD 파이프라인을 구축합니다.

**사용자 스토리**: 
개발자로서, 안전하고 신뢰할 수 있는 방식으로 프로덕션에 배포하고 싶습니다.

**기술 명세**:
1. GitHub Actions 워크플로우 생성 (`.github/workflows/deploy.yml`):
   - 린트 및 타입 체크
   - 단위 테스트 실행
   - 빌드
   - 배포 (Vercel 또는 AWS)
2. 환경 분리:
   - 개발 환경 (development)
   - 스테이징 환경 (staging)
   - 프로덕션 환경 (production)
3. 배포 전략:
   - 자동 배포 (main 브랜치 푸시 시)
   - 롤백 계획
4. 환경 변수 관리 (Vercel Environment Variables 또는 AWS Secrets Manager)

**인수 조건 (Acceptance Criteria)**:
- [ ] CI/CD 파이프라인이 구축되고 자동 배포됨
- [ ] 개발, 스테이징, 프로덕션 환경이 분리됨
- [ ] 배포 후 자동 테스트가 실행됨
- [ ] 롤백 절차가 문서화되고 테스트됨
- [ ] 환경 변수가 안전하게 관리됨
- [ ] 배포 실패 시 알림 전송

**자가 수정 지침**:
배포 파이프라인을 실행하고 각 단계가 성공하는지 확인하세요. 스테이징 환경에서 전체 시스템을 테스트한 후 프로덕션에 배포하세요.

---

### [] Task 6.4: 모니터링 및 로깅 시스템 구축

**컨텍스트**: 
프로덕션 환경에서 시스템 상태를 실시간으로 모니터링하고, 에러를 추적합니다.

**사용자 스토리**: 
개발자로서, 프로덕션 환경에서 발생하는 에러를 즉시 파악하고 대응하고 싶습니다.

**기술 명세**:
1. 에러 트래킹 시스템 통합 (Sentry):
   - 프론트엔드 에러 캡처
   - 백엔드 에러 캡처
   - 소스맵 업로드
2. 성능 모니터링 (Vercel Analytics 또는 Datadog):
   - 페이지 로드 시간
   - API 응답 시간
   - 데이터베이스 쿼리 시간
3. 로깅 시스템 (Winston 또는 Pino):
   - 구조화된 로그
   - 로그 레벨 (error, warn, info, debug)
   - 로그 집계 (Logtail 또는 CloudWatch)
4. 알림 설정:
   - 에러 발생 시 Slack 알림
   - 성능 저하 시 이메일 알림
   - 다운타임 감지 시 PagerDuty 알림

**인수 조건 (Acceptance Criteria)**:
- [ ] 에러 트래킹이 설정되고 에러가 Sentry에 보고됨
- [ ] 성능 모니터링 대시보드가 설정됨
- [ ] 로그가 구조화되어 저장됨
- [ ] 에러 발생 시 Slack 알림 전송
- [ ] 성능 저하 시 이메일 알림 전송
- [ ] 다운타임 감지 시 알림 전송

**자가 수정 지침**:
의도적으로 에러를 발생시켜 Sentry에 보고되는지 확인하세요. 성능 모니터링 대시보드를 열어 메트릭이 수집되는지 검증하세요.

---

### [] Task 6.5: 프로덕션 배포 및 최종 검증

**컨텍스트**: 
모든 개발이 완료되면 프로덕션 환경에 배포하고 최종 검증을 수행합니다.

**사용자 스토리**: 
제품 매니저로서, 프로덕션 환경에서 모든 기능이 정상 작동하는지 확인하고 싶습니다.

**기술 명세**:
1. 프로덕션 배포:
   - 스테이징 환경에서 최종 테스트
   - 프로덕션 환경으로 배포
   - 배포 후 스모크 테스트
2. 최종 검증 체크리스트:
   - 모든 페이지 로드 확인
   - 주요 사용자 플로우 테스트
   - 성능 요구사항 충족 확인
   - 보안 요구사항 충족 확인
3. 문서화:
   - README.md 업데이트
   - API 문서 작성
   - 배포 가이드 작성
   - 트러블슈팅 가이드 작성
4. 사용자 온보딩:
   - 온보딩 튜토리얼 생성
   - 도움말 문서 작성
   - FAQ 작성

**인수 조건 (Acceptance Criteria)**:
- [ ] 프로덕션 환경에 성공적으로 배포됨
- [ ] 모든 페이지가 로드됨
- [ ] 주요 사용자 플로우가 정상 작동함
- [ ] 성능 요구사항 충족 (응답 시간 3초 이내)
- [ ] 보안 요구사항 충족 (HTTPS, 암호화, 인증)
- [ ] 문서가 작성되고 최신 상태로 유지됨
- [ ] 온보딩 튜토리얼이 작성됨

**자가 수정 지침**:
프로덕션 환경에서 실제 CEO 사용자로 로그인하여 전체 플로우를 테스트하세요. 각 기능이 정상 작동하는지, 성능이 요구사항을 충족하는지 확인하세요.

---

## 부록: 개발 체크리스트

### 코드 품질
- [ ] TypeScript strict 모드 사용
- [ ] ESLint 규칙 준수
- [ ] Prettier 포맷팅 적용
- [ ] 주석 및 문서화
- [ ] 단위 테스트 작성 (커버리지 80% 이상)

### 보안
- [ ] 환경 변수로 비밀 정보 관리
- [ ] 입력 검증 및 살균
- [ ] HTTPS 강제
- [ ] CORS 정책 설정
- [ ] Rate limiting 적용

### 성능
- [ ] 데이터베이스 인덱스 최적화
- [ ] LLM API 호출 캐싱
- [ ] 이미지 최적화
- [ ] 코드 스플리팅
- [ ] Lazy loading

### 접근성
- [ ] WCAG 2.1 AA 준수
- [ ] 키보드 탐색 가능
- [ ] 스크린 리더 지원
- [ ] 색상 대비 충족
- [ ] 포커스 표시

### 문서화
- [ ] README.md 작성
- [ ] API 문서 작성
- [ ] 배포 가이드 작성
- [ ] 트러블슈팅 가이드 작성

---

**문서 버전 관리**  
- v1.0 (2026-01-10): 초기 작성, 6개 마일스톤 정의
- 다음 업데이트: 개발 진행에 따라 실제 구현 경험 반영